<!DOCTYPE html>
<html lang="en-us">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>The shadowy art of classical shadows - Part 2 - My Mind Closet</title><meta name="Description" content="A place where I stow my thoughts on a variety of topics"><meta property="og:title" content="The shadowy art of classical shadows - Part 2" />
<meta property="og:description" content="Randomized Measurements and Shadows (a.k.a Part 2) In the earlier blog post I had described the an interesting piece of quantum information science literature - classical shadows. The overreaching idea was to use random measurements to obtain some information about an unknown quantum state without requiring to store (or know) multiple copies of that state and re-construct it. Classical shadows have two advantages when it comes to today&rsquo;s state of quantum computing." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://aicaffeinelife.github.io/posts/2024_06_07_classical_shadows/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-06-11T15:00:40+00:00" />
<meta property="article:modified_time" content="2024-06-11T15:00:40+00:00" /><meta property="og:site_name" content="My Mind Closet" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="The shadowy art of classical shadows - Part 2"/>
<meta name="twitter:description" content="Randomized Measurements and Shadows (a.k.a Part 2) In the earlier blog post I had described the an interesting piece of quantum information science literature - classical shadows. The overreaching idea was to use random measurements to obtain some information about an unknown quantum state without requiring to store (or know) multiple copies of that state and re-construct it. Classical shadows have two advantages when it comes to today&rsquo;s state of quantum computing."/>
<meta name="application-name" content="My cool site">
<meta name="apple-mobile-web-app-title" content="My cool site"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://aicaffeinelife.github.io/posts/2024_06_07_classical_shadows/" /><link rel="prev" href="https://aicaffeinelife.github.io/posts/2024_05_08_classical_shadows/" /><link rel="next" href="https://aicaffeinelife.github.io/posts/2025_07_23_fairlearn/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "The shadowy art of classical shadows - Part 2",
        "inLanguage": "en-us",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/aicaffeinelife.github.io\/posts\/2024_06_07_classical_shadows\/"
        },"genre": "posts","wordcount":  2082 ,
        "url": "https:\/\/aicaffeinelife.github.io\/posts\/2024_06_07_classical_shadows\/","datePublished": "2024-06-11T15:00:40+00:00","dateModified": "2024-06-11T15:00:40+00:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "Ankit Kulshrestha"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="My Mind Closet">My Mind Closet</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/about"> About </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="My Mind Closet">My Mind Closet</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/about" title="">About</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">The shadowy art of classical shadows - Part 2</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="akulsh912.com" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>Ankit Kulshrestha</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2024-06-11">2024-06-11</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;2082 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;10 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#randomized-measurements-measurement-protocol">Randomized Measurements: Measurement Protocol</a></li>
    <li><a href="#applications-of-classical-shadows">Applications of Classical Shadows</a>
      <ul>
        <li><a href="#classical-shadows-as-data-format">Classical Shadows as Data Format</a></li>
        <li><a href="#quantum-fidelity-estimation">Quantum Fidelity Estimation</a></li>
        <li><a href="#variational-quantum-algorithms-vqas">Variational Quantum Algorithms (VQAs)</a></li>
      </ul>
    </li>
    <li><a href="#conclusions">Conclusions</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="randomized-measurements-and-shadows-aka-part-2">Randomized Measurements and Shadows (a.k.a Part 2)</h1>
<p>In the <a href="https://aicaffeinelife.github.io/posts/2024_05_08_classical_shadows/" target="_blank" rel="noopener noreffer ">earlier blog post</a> I had described the an interesting piece of quantum information science literature - classical shadows. The overreaching idea was to use random measurements to obtain some information about an unknown quantum state without requiring to store (or know) multiple copies of that state and re-construct it. Classical shadows have two advantages when it comes to today&rsquo;s state of quantum computing. First, they are <em>measurement efficient</em> i.e. they allow us to reconstruct <em>any</em> quantum state and make predictions on those independent of the system size (i.e. the number of qubits in the state). Second, they provide us a way for mapping a quantum quantity (heh) to something that can be handled by existing computers (classical computers).</p>
<p>In this post, I am going to make the empirical protocol much more precise and discuss the applications that arise due to the second property of classical shadows. At the end of this post, I hope to convince you to pay a closer look at classical shadows and think of interesting ways you can incorporate quantum computers in your optimization tasks or vice versa.</p>
<p>Much of the material for this post is derived from a seminal paper by <a href="https://arxiv.org/pdf/2203.11374" target="_blank" rel="noopener noreffer ">Elben <em>et al</em></a>. Many of the pictures in this blogpost are from that paper as well.</p>
<h2 id="randomized-measurements-measurement-protocol">Randomized Measurements: Measurement Protocol</h2>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/classical_shadows_p2/rand_measurements.png"
        data-srcset="/classical_shadows_p2/rand_measurements.png, /classical_shadows_p2/rand_measurements.png 1.5x, /classical_shadows_p2/rand_measurements.png 2x"
        data-sizes="auto"
        alt="/classical_shadows_p2/rand_measurements.png"
        title="alt" /></p>
<p>The first step in classical shadows is to acquire shadows from an unknown quantum state $|\psi\rangle \in C^{\otimes n}$. In order to do so with randomized measurements, we use the following algorithm:</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/classical_shadows_p2/rmt_acquisition.png"
        data-srcset="/classical_shadows_p2/rmt_acquisition.png, /classical_shadows_p2/rmt_acquisition.png 1.5x, /classical_shadows_p2/rmt_acquisition.png 2x"
        data-sizes="auto"
        alt="/classical_shadows_p2/rmt_acquisition.png"
        title="alt" /></p>
<p>Here, in the worst case we use $O(MKN)$ time and memory to acquire and use the shadows. This may seem a lot, but it is relatively cheaper than requiring to store $O(K. 2^{N} . 2^{N})$ copies for a full state tomorgraphy. However, these asymptotics are in the worst case. Many times we can get away with keeping $M, K$ to a reasonably large value and save on both time and memory. This is because our goal in classical shadows is <em>not</em> to perform a full shadow tomography(it is, but it&rsquo;s not what makes them super useful) but to predict properties of many observables simultaneously.</p>
<p>We can consider two extreme cases and see the usefulness of the protocol. First, when $M=1$, we sample an observable <em>once</em> during the entire acquisition process and repeat the measurement $K$ times. When a shadow is obtained in this manner, we can predict linear values like $Tr[O\rho]$ for different $O$ provided they are in the <em>exact</em> same basis as the sampled observable. For instance, let&rsquo;s say for a 3-qubit system the sampled observable was $X \otimes Z \otimes Z$. Then, we can predict observables of the form $\alpha X \otimes \beta Z \otimes \gamma Z$ for different values of $\alpha, \beta, \gamma$.</p>
<p>The first case is fun, but limits us to a single observable that we sampled at random. When we do the opposite i.e. $K=1$ it means that we will sample $M$ different observables and the shadow will be a measurement in those $M$ different basis. Going back to our 3 qubit example, lets say we sampled $Z \otimes Z \otimes X$ , $X \otimes X$, $Y \otimes Z \otimes X$ and acquired the shadow. Then we can measure values for $Tr[O\rho]$ for <em>any</em> $O$ that has a matching basis on that qubit. In this case, we sacrifice the accuracy of obtaining a shadow for a basis to be able to combine expected values from an ensemble of diverse observables. A situation like this is shown in the picture:</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/classical_shadows_p2/rmt_evaluation_multiple_obs.png"
        data-srcset="/classical_shadows_p2/rmt_evaluation_multiple_obs.png, /classical_shadows_p2/rmt_evaluation_multiple_obs.png 1.5x, /classical_shadows_p2/rmt_evaluation_multiple_obs.png 2x"
        data-sizes="auto"
        alt="/classical_shadows_p2/rmt_evaluation_multiple_obs.png"
        title="alt" /></p>
<p>Computing the values of $M$ observables and reconstruction of the shadow $\hat{\rho}$ is same as described in the previous blog post. I&rsquo;ll restate these succintly in equation form here:</p>
<p>$$
\hat{o} = \frac{1}{M}\sum_{m=1}^{M} tr(O\hat{\rho}^{(m)})
$$</p>
<p>$$
\hat{\rho}^{(m)} = \frac{1}{K}\sum_{i=1}^{K} \bigotimes_{n=1}^{N} (3(U_n^{(m)})^{\dagger}|s^{m,k}_n\rangle \langle s_n^{(m, k)}| U^{(m)}_n - \mathbb{I})
$$</p>
<h2 id="applications-of-classical-shadows">Applications of Classical Shadows</h2>
<p>Once we&rsquo;ve construted our fighter plane, let&rsquo;s see what it can do.</p>
<h3 id="classical-shadows-as-data-format">Classical Shadows as Data Format</h3>
<p>Since classical shadows act as a way to map quantum to classsical information, we can use them as a data format for many downstream applications. In the <a href="https://arxiv.org/pdf/2203.11374" target="_blank" rel="noopener noreffer ">RMT</a> paper, the authors propose to use the information provided by a classical shadow $S^{(M, K,N)}$ as <em>data</em> to train a machine learning model for detecting <a href="https://arxiv.org/abs/hep-th/0510092" target="_blank" rel="noopener noreffer ">topological entanglement entropy</a> for different kinds of quantum models.</p>
<p>In the paper, the authors consider detecting this non-linear entropy for an XXZ model and toric code topological phase. The exact description of these systems is beyond the current scope of this post, and I&rsquo;ll stick to the results:</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/classical_shadows_p2/shadow_ml_state_classif.png"
        data-srcset="/classical_shadows_p2/shadow_ml_state_classif.png, /classical_shadows_p2/shadow_ml_state_classif.png 1.5x, /classical_shadows_p2/shadow_ml_state_classif.png 2x"
        data-sizes="auto"
        alt="/classical_shadows_p2/shadow_ml_state_classif.png"
        title="alt" /></p>
<p>These results show very interesting things. First, in the left plot we can clearly see that the shadow obtained from a <em>quantum</em> system has a natural clustering in <em>classical</em> space even when the number of measurements are finite. Second, in the right plot we can see that a shadow provides important <em>a-priori</em> information to a classical machine learning algorithm and enables it to perform a discriminative classification much more effectively as compared with just training on a raw quantum data.</p>
<h3 id="quantum-fidelity-estimation">Quantum Fidelity Estimation</h3>
<p>One of the most important quantities in quantum information science is <em>fidelity</em>. In simple terms, it estimates the degree of closeness for any two quantum states. The classical analog of fidelity is the cosine distance in Euclidean space. In classical ML tasks, we typically can access two vectors $\textbf{x}, \textbf{y}$ in polynomial time and thus compute the cosine distance efficiently.</p>
<p>The same is not true for quantum states since the only way to access an unknown quantum state is to reconstruct that state and then estimate the fidelity. Needless to say, this procedure does not scale for large system sizes. Moreover, there are two kinds of fidelity estimation we are interested in performing:</p>
<ol>
<li>
<p>Maximum Fidelity Estimation: Estimate correlation between two arbitrary states $\rho_1, \rho_2$</p>
</li>
<li>
<p>Direct Fidelity Estimation: Estimate the overlap between a <em>pure</em> quantum state $|\psi\rangle$ and a unknown given state $\rho$ (most likely prepared with imperfect instruments).</p>
</li>
</ol>
<p>Classical shadows to the rescue! Let&rsquo;s first consider the case of maximum fidelity estimation. We&rsquo;re interested in the quantity:</p>
<p>$$
\mathcal{F}_{max} = \frac{Tr[\rho_1\rho_2]}{max[Tr[\rho^2_1], Tr[\rho^2_2]]}
$$</p>
<p>The bottleneck is the reconstruction of $\rho_1, \rho_2$ directly. We use the randomized measurement protocol to estimate $S_1(M, K, N)$ and $S_2(M, K, N)$. Since we know that this shadow reconstructs the input state in expectation, we can compute a statistical correlation (e.g. Pearson correlation, Spearman correlation) that will give us $Tr[\rho_1, \rho_2]$ <em>by proxy</em>. A large value of correlation coefficient will indicate a large overlap while a value of 0 will indicate two completely different systems.</p>
<p>The case of direct fidelity estimation is a bit more challenging since we have a known pure state $|\psi\rangle$ and an unknown quantum state $\rho$. The fidelity given as $Tr[\rho\psi]$ cannot be approximated by proxy like a statistical correlation since one system is known. Instead, the authors in the paper propose to proceed as follows:</p>
<p>Write $\rho = \sum_j a_j Q_j$ where $Q_j \in {I, X, Y, Z}$ and $|\psi\rangle = \sum_j b_j Q_j$. Then</p>
<p>$$
\mathcal{F}(\rho, \psi) = \sum_j a_j b_j = \sum_j (\frac{a_j}{b_j}) b^2_j
$$</p>
<p>The expansion of states can be understood as writing them in terms of weighted Pauli coefficients. The equality then arises since $Q^2_j = 1$. The last expression can be interpreted as an expectation over a known distribution $b_j$ with a random variable being the ratio of coefficients between known quantum states and unknown state. With classical shadows we can estimate $\mathcal{F}$ upto an accuracy of $\varepsilon$ by sampling $O(\frac{1}{\varepsilon^2})$ observables from the distribution of $b^2_j$ and estimating $Tr[O\rho]$. We know classical shadows allow us to do this independent of system size and in logarithmic time :)</p>
<p>A result for estimating fidelity with a 7 qubit GHZ state on various IBM devices and Ion-trap devices shows that we can indeed estimate the fidelity values efficiently. Part (a)  shows the cross device fidelity on various devices and (b) shows the distribution of the random variable $(\frac{a_j}{b_j})$ for a 14-qubit quantum state.</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/classical_shadows_p2/dfe_estimation_shadows.png"
        data-srcset="/classical_shadows_p2/dfe_estimation_shadows.png, /classical_shadows_p2/dfe_estimation_shadows.png 1.5x, /classical_shadows_p2/dfe_estimation_shadows.png 2x"
        data-sizes="auto"
        alt="/classical_shadows_p2/dfe_estimation_shadows.png"
        title="alt" /></p>
<h3 id="variational-quantum-algorithms-vqas">Variational Quantum Algorithms (VQAs)</h3>
<p>VQAs are currently heavily researched in quantum computing since they promise to help us leverage a (hypothetical) quantum computer in the near future. The typical way of training a VQA is to instantitate parameters on a classical computer and use them to estimate measurement for some observable on a quantum computers. The paramters are updated using gradient descent like procedure.</p>
<p>Quantum circuits are composed of unitary matrices that are applied to some input quantum state $|0\rangle$ to produce some mixed output state $\rho_{out}$. Typically, these unitary matrices are represented as <em>gates</em> in  a circuit (much in the same way we&rsquo;re used to seeing digital gates like AND, OR, NOT except these are <em>analog</em> gates). Variational quantum circuits add a real valued parameter $\theta$ to each gate. We can think these circuits in terms of layers where unitarites are applied one after the other:</p>
<p>$$
U(\vec{\theta}) = \prod_{l=1}^L U(\theta_l)
$$</p>
<p>In a very crude way, these quantum circuits can be interpreted as <em>linear networks</em> whose real valued weights are optimized for a given cost function $C(\theta)$ on a <em>classical</em> computer. In simpler terms, we can think of these circuits running some analog quantum computation with given parameters on a quantum computer that&rsquo;s attached as a co-processor and the parameters themselves are being adjusted on the main CPU.</p>
<p>Now that we&rsquo;ve successfully distilled the power of known universe to our desktop computation, it&rsquo;s time to look at <em>what</em> cost function we&rsquo;re optimizing. Typically, the cost function we&rsquo;re interested in is of the form:</p>
<p>$$
C(\vec{\theta}) = Tr[U(\vec{\theta})O\rho_{in}U^{\dagger}(\vec{\theta})]
$$</p>
<p>Here $O$ is the observable we&rsquo;re interested in predicting. $U(\vec{\theta})\rho_{in}U^{\dagger}(\vec{\theta})$ is the output quantum state produced by the action of the quantum circuit. If you&rsquo;ve followed along thus far, there should be a gleam in your eyes and a smirk on your face since this cost function is <em>very</em> similar to the form $Tr[O\rho]$ which we <em>know</em> we can estimate efficiently using classical shadows. In fact, classical shadows enable us to do something better - We can estimate $C_{1}(\vec{\theta}), C_{2}(\vec{\theta}) \dots C_{M}(\vec{\theta})$ in parallel for $M$ observables in $\sim O(log M)$ time!</p>
<p>Given the utility of classical shadows in this scenario, there are lots of ways they have been explored in recent literature. I&rsquo;m going to look at some interesting examples that represent the possibilites in the NISQ era:</p>
<ol>
<li>
<p><a href="https://arxiv.org/abs/2208.11623" target="_blank" rel="noopener noreffer ">Alternating Layered Variational Quantum Circuits Can Be Classically Optimized Efficiently Using Classical Shadows</a> Basheer <em>et al</em>: Leverage classical shadows to reduce the number of function evaluations in an alternating layer ansatz and single qubit observables. Their proposed approach reduces the number of function evaluations for $L$ steps to $~\sim O(log L)$ from $O(L)$.</p>
</li>
<li>
<p><a href="https://arxiv.org/abs/2201.08194" target="_blank" rel="noopener noreffer ">Avoiding Barren Plateaus using Classical Shadows</a> Stefan Sack <em>et al</em>: VQAs suffer from a <em>pain in the ass</em> called barren plateaus. They are regions on optimization surface where the mean of gradients converges to zero and variance decays exponentially with increasing system size. In this paper, the authors characterize <em>weak</em> barren plateaus as a point where the Renýi entroy $S_2 = -ln\ tr[\rho^2_A] \geq \alpha S^{page}$. Where, $S^{page}$ is the entropy of the maximally scrambled state and is approximated as $S^{page} = K ln 2 - \frac{1}{2^{N-2K+1}}$ where $K &laquo; N$ and $A$ is the subsystem we&rsquo;re interested in. Their proposal is to estimate $S_2$ using shadows during optimization for some value of $\alpha \in [0, 1)$ and adjust the learning rate accordingly.</p>
</li>
<li>
<p><a href="https://arxiv.org/abs/2204.08494" target="_blank" rel="noopener noreffer ">Training variational quantum circuits with CoVaR: covariance root finding with classical shadows</a>: Traditional VQE algorithms seek to find the ground state associated with a Hamiltonian of a molecule. This ground state typically is some eigenstate of the Hamiltonian, estimated via parameter optimization. In this paper, the authors propose to find this eigenstate by estimating covariance between the problem Hamiltonian and their chosen set of observables. In order to do so at scale, they propose to use shadows to minimize calls to a quantum circuit and evaluate the necessary equations on the classical computer.</p>
</li>
</ol>
<h2 id="conclusions">Conclusions</h2>
<p>In these two blog posts, I&rsquo;ve tried to present a picture on the usefulness of classical shadows in quantum information science. I&rsquo;ve shown them to be useful in situations where quantum computation is cumbersome and one needs a way to process information using classical computers <em>efficiently</em>. I&rsquo;ve given some examples of creative uses of shadows in near term quantum computers. Hopefully, if you&rsquo;ve stuck with me so far you will be inspired to give a closer look to shadows and think of using them in any of your own projects.</p>
<p>Till next time!</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2024-06-11</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="https://aicaffeinelife.github.io/posts/2024_06_07_classical_shadows/" data-title="The shadowy art of classical shadows - Part 2" data-via="aicaffeinelife"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="https://aicaffeinelife.github.io/posts/2024_06_07_classical_shadows/"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Hacker News" data-sharer="hackernews" data-url="https://aicaffeinelife.github.io/posts/2024_06_07_classical_shadows/" data-title="The shadowy art of classical shadows - Part 2"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="https://aicaffeinelife.github.io/posts/2024_06_07_classical_shadows/" data-title="The shadowy art of classical shadows - Part 2"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="https://aicaffeinelife.github.io/posts/2024_06_07_classical_shadows/" data-title="The shadowy art of classical shadows - Part 2"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/2024_05_08_classical_shadows/" class="prev" rel="prev" title="The shadowy art of classical shadows - Part 1"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>The shadowy art of classical shadows - Part 1</a>
            <a href="/posts/2025_07_23_fairlearn/" class="next" rel="next" title="In all fairness: Engineering Fairness in Modern Machine Learning Algorithms">In all fairness: Engineering Fairness in Modern Machine Learning Algorithms<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.119.0">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2022 - 2025</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="akulsh912.com" target="_blank">Ankit Kulshrestha</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
